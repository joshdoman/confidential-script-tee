# Enclave-Native Reproducible Key

This project demonstrates a powerful cryptographic pattern for creating a secure, reproducible secret key within a hardware-based secure enclave. It acts as a foundational building block for more complex decentralized and trustless applications.

The server exposes a key pair (`secp256k1::SecretKey`, `secp256k1::PublicKey`) that is generated deterministically from an AWS KMS key. The crucial security guarantee is that the **secret key never leaves the enclave**.

## Core Concept

The goal is to generate a secret key inside an enclave in a way that is both **secure** and **reproducible**. Any party can run this same enclave, provide the same KMS key, and derive the exact same internal secret, without that secret ever being known to the party itself or any other observer.

This allows the enclave to perform deterministic computations, such as signing messages, where the resulting signature can be trusted because it was created by specific, audited code running in a verified environment.

## How It Works

The process is simple and robust, consisting of two main stages:

1.  **Startup: NUMS Key Generation**
    *   On initialization, the server generates a "Nothing-Up-My-Sleeve" (NUMS) public key.
    *   This key is generated by hashing a public seed string (`"This is a secp256k1 NUMS key"`) and incrementing a counter until a valid point on the `secp256k1` curve is found.
    *   This process proves that the server's internal key was not crafted with a backdoor, as its corresponding private key is provably unknown to anyone.

2.  **Runtime: API Endpoints**
    *   `POST /generate-secret`: A user provides the ARN of an AWS KMS key. The enclave uses its NUMS key and the provided KMS key to call `kms:DeriveSharedSecret`. The result is a 32-byte shared secret. This secret is then deterministically converted into a valid `secp256k1::SecretKey` and stored immutably in memory. This endpoint can only be successfully called **once**.
    *   `GET /retrieve-public-key`: This endpoint returns the `PublicKey` corresponding to the securely stored `SecretKey`. The public key is cached for instant, lock-free reads.

## Security & Trust Model

*   **Confidentiality**: The final `SecretKey` is born inside the enclave and never leaves it. All operations on the key happen within the secure boundary.
*   **Reproducibility**: The key generation is entirely deterministic. The same enclave code + the same KMS key ARN will *always* result in the same secret key pair.
*   **Trustlessness via Attestation**: The true power of this model is realized when the AWS KMS key policy is configured to grant `DeriveSharedSecret` permissions **only** to an enclave with a specific cryptographic measurement (the `PCR0` hash). This ensures that no other machine or piece of code in the world can derive the secret.

## A Foundation for Larger Projects

This server is designed as a minimal, secure core. It provides the fundamental capability of a deterministic, confidential key. Larger projects can be built on this foundation to perform powerful computations, such as:

*   **Deterministic Signing**: Create a trustless oracle or notary that signs data.
*   **Threshold Signature Schemes**: Act as a participant in a multi-party computation (MPC) network.
*   **Private Data Computation**: Use the key to decrypt and perform calculations on confidential data submitted by users.

## Usage

1.  **Deploy** the enclave to a Nitro Enclaves-enabled instance, using [enclaver](https://github.com/enclaver-io/enclaver/tree/ef82f1490857e7550b1974f6b9f6dda6ae103685).
2.  **Configure** an AWS KMS key with a policy that allows your enclave's `PCR0` hash to call `kms:DeriveSharedSecret`.
3.  **Generate the Secret**:
    ```bash
    curl -X POST http://<enclave-ip>:8001/generate-secret \
      -H "Content-Type: application/json" \
      -d '{
        "key_id": "arn:aws:kms:us-east-1:123456789012:key/your-kms-key-id"
      }'
    ```
4.  **Retrieve the Public Key**:
    ```bash
    curl http://<enclave-ip>:8001/retrieve-public-key
    ```

## Running Locally

```
docker build --build-arg LOCAL=true -t demo-enclave -f Dockerfile . && docker run --name enclave -d -p 8001:8001 -e AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID -e AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY -e AWS_DEFAULT_REGION=us-east-1 -e AWS_SESSION_TOKEN=$AWS_SESSION_TOKEN --rm demo-enclave
```